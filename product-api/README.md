This is backend for the project. You will need to fill these parameters in .env:

SUPABASE_URL=                   //Your Supabase server URL
SUPABASE_SERVICE_ROLE_KEY=      //Your Supabase service key
JWT_SECRET=                     //Random generated value for JWT
RESERVATION_OPENS_AT=           //Format: 2025-09-15T18:00:00+03:00
RESERVATION_CLOSES_AT=          //Format: 2025-09-16T18:00:00+03:00
PORT =                          //Port for the backend server to run




Run this schema in your SQL database:

-- ====== EXTENSIONS ======
create extension if not exists pgcrypto;

-- ====== TABLES ======
-- products (integer IDs, auto-increment, numeric sorting by default)
create table if not exists products (
  id              integer primary key generated by default as identity,
  name            text    not null,
  available       integer not null default 0,
  max_per_user    integer not null default 0,
  price           numeric not null default 0,
  info            text
);

-- users
create table if not exists users (
  username text primary key,
  name     text not null,
  email    text not null unique,
  password text not null
);

-- reservations
create table if not exists reservations (
  id          uuid primary key default gen_random_uuid(),
  username    text not null references users(username) on delete cascade,
  reserved_at timestamptz not null default now()
);

-- reservation_items (composite PK, integer product_id)
create table if not exists reservation_items (
  reservation_id uuid    not null references reservations(id) on delete cascade,
  product_id     integer not null references products(id)     on delete cascade,
  quantity       integer not null check (quantity > 0),
  primary key (reservation_id, product_id)
);

-- ====== INDEXES (performance) ======
create index if not exists reservations_username_idx   on reservations(username);
create index if not exists reservation_items_pid_idx   on reservation_items(product_id);
create index if not exists products_name_idx           on products(lower(name));

-- ====== FUNCTION: reserve_flexible (integer product IDs) ======
create or replace function public.reserve_flexible(p_username text, p_items jsonb)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_now           timestamptz := now();
  v_latest_id     uuid;
  v_items         jsonb := coalesce(p_items, '[]'::jsonb);
  v_row           record;
  v_items_out     jsonb := '[]'::jsonb;
  v_partials_out  jsonb := '[]'::jsonb;
  v_reserved_any  boolean := false;
begin
  if jsonb_typeof(v_items) <> 'array' then
    raise exception 'p_items must be an array';
  end if;

  -- 1) Return user's latest reservation (if any) back to stock, then delete it
  select r.id
    into v_latest_id
  from reservations r
  where r.username = p_username
  order by r.reserved_at desc
  limit 1;

  if v_latest_id is not null then
    for v_row in
      select product_id, quantity
      from reservation_items
      where reservation_id = v_latest_id
    loop
      update products
         set available = available + v_row.quantity
       where id = v_row.product_id;
    end loop;

    delete from reservation_items where reservation_id = v_latest_id;
    delete from reservations      where id            = v_latest_id;
  end if;

  -- 2) Merge duplicates, enforce max_per_user & availability
  for v_row in
    with merged as (
      select (i->>'productId')::int as product_id,
             sum((i->>'quantity')::int) as requested
      from jsonb_array_elements(v_items) i
      group by 1
    )
    select m.product_id,
           m.requested,
           p.available,
           coalesce(p.max_per_user, 0) as max_per_user
    from merged m
    join products p on p.id = m.product_id
  loop
    declare
      v_allowed int := case
                         when v_row.max_per_user > 0
                           then least(v_row.requested, v_row.max_per_user)
                         else v_row.requested
                       end;
      v_reserve int := least(v_row.available, v_allowed);
      v_missing int := v_row.requested - v_reserve;
    begin
      if v_reserve > 0 then
        v_reserved_any := true;

        v_items_out := v_items_out || jsonb_build_array(
          jsonb_build_object('productId', v_row.product_id, 'quantity', v_reserve)
        );

        update products
           set available = available - v_reserve
         where id = v_row.product_id;
      end if;

      if v_missing > 0 then
        v_partials_out := v_partials_out || jsonb_build_array(
          jsonb_build_object(
            'productId', v_row.product_id,
            'requested', v_row.requested,
            'reserved',  v_reserve,
            'missing',   v_missing
          )
        );
      end if;
    end;
  end loop;

  -- 3) If nothing reserved â†’ do not create a new reservation
  if not v_reserved_any then
    return jsonb_build_object(
      'status',      'partial',
      'reserved_at', v_now,
      'items',       v_items_out,
      'partials',    v_partials_out
    );
  end if;

  -- 4) Create a new reservation + its items
  declare
    v_new_id uuid := gen_random_uuid();
    v_it     jsonb;
  begin
    insert into reservations(id, username, reserved_at)
    values (v_new_id, p_username, v_now);

    for v_it in select * from jsonb_array_elements(v_items_out)
    loop
      insert into reservation_items(reservation_id, product_id, quantity)
      values (
        v_new_id,
        (v_it->>'productId')::int,
        (v_it->>'quantity')::int
      );
    end loop;
  end;

  -- 5) Return result (full vs partial)
  return jsonb_build_object(
    'status',      case when jsonb_array_length(v_partials_out) = 0 then 'full' else 'partial' end,
    'reserved_at', v_now,
    'items',       v_items_out,
    'partials',    v_partials_out
  );
end;
$$;

-- ====== (Optional) DEV ONLY: disable RLS if you had it on ======
alter table products           disable row level security;
alter table users              disable row level security;
alter table reservations       disable row level security;
alter table reservation_items  disable row level security;

-- ====== QUICK CHECKS ======
-- Orphans (should be 0)
-- select count(*) as orphan_count
-- from reservation_items ri
-- left join products p on p.id = ri.product_id
-- where p.id is null;

-- Example: list products in numeric order
-- select id, name, available from products order by id;





Product schema:
id              //Int, unique. In order
name            //String
available       //Int, how many of product you want to sell
max_per_user    //Int, max how many each person can order. 0 = infinite
price           //Num
info            //String, info of the product shown to user


User schema:
username        //String, unique. Used in login
name            //String, don't yet have affect
email           //String, don't yet have affect
password        //String, restored in SQL that don't use hash. Major flaw.


